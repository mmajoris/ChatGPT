{"mappings":"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","sources":["packages/react-resizable-panels/src/index.ts","packages/react-resizable-panels/src/Panel.ts","packages/react-resizable-panels/src/hooks/useIsomorphicEffect.ts","packages/react-resizable-panels/src/hooks/useUniqueId.ts","packages/react-resizable-panels/src/PanelContexts.ts","packages/react-resizable-panels/src/PanelGroup.ts","packages/react-resizable-panels/src/utils/serialization.ts","packages/react-resizable-panels/src/utils/coordinates.ts","packages/react-resizable-panels/src/constants.ts","packages/react-resizable-panels/src/utils/group.ts","packages/react-resizable-panels/src/hooks/useWindowSplitterBehavior.ts","packages/react-resizable-panels/src/utils/cursor.ts","packages/react-resizable-panels/src/utils/debounce.ts","packages/react-resizable-panels/src/PanelResizeHandle.ts"],"sourcesContent":["import { Panel } from \"./Panel\";\nimport { PanelGroup } from \"./PanelGroup\";\nimport { PanelResizeHandle } from \"./PanelResizeHandle\";\n\nimport type { ImperativePanelHandle, PanelProps } from \"./Panel\";\nimport type { PanelGroupProps } from \"./PanelGroup\";\nimport type { PanelResizeHandleProps } from \"./PanelResizeHandle\";\n\nexport {\n  Panel,\n  PanelGroup,\n  PanelResizeHandle,\n\n  // TypeScript types\n  ImperativePanelHandle,\n  PanelGroupProps,\n  PanelProps,\n  PanelResizeHandleProps,\n};\n","import {\n  createElement,\n  CSSProperties,\n  ElementType,\n  ForwardedRef,\n  forwardRef,\n  ReactNode,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n} from \"react\";\nimport useIsomorphicLayoutEffect from \"./hooks/useIsomorphicEffect\";\nimport useUniqueId from \"./hooks/useUniqueId\";\n\nimport { PanelGroupContext } from \"./PanelContexts\";\nimport { PanelOnCollapse, PanelOnResize } from \"./types\";\n\nexport type PanelProps = {\n  children?: ReactNode;\n  className?: string;\n  collapsible?: boolean;\n  defaultSize?: number | null;\n  id?: string | null;\n  maxSize?: number;\n  minSize?: number;\n  onCollapse?: PanelOnCollapse | null;\n  onResize?: PanelOnResize | null;\n  order?: number | null;\n  style?: CSSProperties;\n  tagName?: ElementType;\n};\n\nexport type ImperativePanelHandle = {\n  collapse: () => void;\n  expand: () => void;\n  getCollapsed(): boolean;\n  getSize(): number;\n  resize: (percentage: number) => void;\n};\n\nfunction PanelWithForwardedRef({\n  children = null,\n  className: classNameFromProps = \"\",\n  collapsible = false,\n  defaultSize = null,\n  forwardedRef,\n  id: idFromProps = null,\n  maxSize = 100,\n  minSize = 10,\n  onCollapse = null,\n  onResize = null,\n  order = null,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n}: PanelProps & {\n  forwardedRef: ForwardedRef<ImperativePanelHandle>;\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(\n      `Panel components must be rendered within a PanelGroup container`\n    );\n  }\n\n  const panelId = useUniqueId(idFromProps);\n\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelStyle,\n    registerPanel,\n    resizePanel,\n    unregisterPanel,\n  } = context;\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef<{\n    onCollapse: PanelOnCollapse | null;\n    onResize: PanelOnResize | null;\n  }>({ onCollapse, onResize });\n  useEffect(() => {\n    callbacksRef.current.onCollapse = onCollapse;\n    callbacksRef.current.onResize = onResize;\n  });\n\n  // Basic props validation\n  if (minSize < 0 || minSize > 100) {\n    throw Error(`Panel minSize must be between 0 and 100, but was ${minSize}`);\n  } else if (maxSize < 0 || maxSize > 100) {\n    throw Error(`Panel maxSize must be between 0 and 100, but was ${maxSize}`);\n  } else {\n    if (defaultSize !== null) {\n      if (defaultSize < 0 || defaultSize > 100) {\n        throw Error(\n          `Panel defaultSize must be between 0 and 100, but was ${defaultSize}`\n        );\n      } else if (minSize > defaultSize && !collapsible) {\n        console.error(\n          `Panel minSize ${minSize} cannot be greater than defaultSize ${defaultSize}`\n        );\n\n        defaultSize = minSize;\n      }\n    }\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    const panel = {\n      callbacksRef,\n      collapsible,\n      defaultSize,\n      id: panelId,\n      maxSize,\n      minSize,\n      order,\n    };\n\n    registerPanel(panelId, panel);\n\n    return () => {\n      unregisterPanel(panelId);\n    };\n  }, [\n    collapsible,\n    defaultSize,\n    panelId,\n    maxSize,\n    minSize,\n    order,\n    registerPanel,\n    unregisterPanel,\n  ]);\n\n  const style = getPanelStyle(panelId);\n\n  const committedValuesRef = useRef<{\n    size: number;\n  }>({\n    size: parseSizeFromStyle(style),\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.size = parseSizeFromStyle(style);\n  });\n\n  useImperativeHandle(\n    forwardedRef,\n    () => ({\n      collapse: () => collapsePanel(panelId),\n      expand: () => expandPanel(panelId),\n      getCollapsed() {\n        return committedValuesRef.current.size === 0;\n      },\n      getSize() {\n        return committedValuesRef.current.size;\n      },\n      resize: (percentage: number) => resizePanel(panelId, percentage),\n    }),\n    [collapsePanel, expandPanel, panelId, resizePanel]\n  );\n\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1),\n    id: `data-panel-id-${panelId}`,\n    style: {\n      ...style,\n      ...styleFromProps,\n    },\n  });\n}\n\nexport const Panel = forwardRef<ImperativePanelHandle, PanelProps>(\n  (props: PanelProps, ref: ForwardedRef<ImperativePanelHandle>) =>\n    createElement(PanelWithForwardedRef, { ...props, forwardedRef: ref })\n);\n\n// Workaround for Parcel scope hoisting (which renames objects/functions).\n// Casting to :any is required to avoid corrupting the generated TypeScript types.\n// See github.com/parcel-bundler/parcel/issues/8724\n(PanelWithForwardedRef as any).displayName = \"Panel\";\n(Panel as any).displayName = \"forwardRef(Panel)\";\n\n// HACK\nfunction parseSizeFromStyle(style: CSSProperties): number {\n  const { flexGrow } = style;\n  if (typeof flexGrow === \"string\") {\n    return parseFloat(flexGrow);\n  } else {\n    return flexGrow;\n  }\n}\n","import { useEffect, useLayoutEffect } from \"react\";\n\nconst canUseEffectHooks = !!(\n  typeof window !== \"undefined\" &&\n  typeof window.document !== \"undefined\" &&\n  typeof window.document.createElement !== \"undefined\"\n);\n\nconst useIsomorphicLayoutEffect = canUseEffectHooks\n  ? useLayoutEffect\n  : () => {};\n\nexport default useIsomorphicLayoutEffect;\n","import { useId, useRef } from \"react\";\n\nlet counter = 0;\n\nexport default function useUniqueId(\n  idFromParams: string | null = null\n): string {\n  const idFromUseId = typeof useId === \"function\" ? useId() : null;\n\n  const idRef = useRef<string | null>(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n\n  return idRef.current;\n}\n","import { CSSProperties, createContext } from \"react\";\n\nimport { PanelData, ResizeEvent, ResizeHandler } from \"./types\";\n\nexport const PanelGroupContext = createContext<{\n  activeHandleId: string | null;\n  collapsePanel: (id: string) => void;\n  direction: \"horizontal\" | \"vertical\";\n  expandPanel: (id: string) => void;\n  getPanelStyle: (id: string) => CSSProperties;\n  groupId: string;\n  registerPanel: (id: string, panel: PanelData) => void;\n  registerResizeHandle: (id: string) => ResizeHandler;\n  resizePanel: (id: string, percentage: number) => void;\n  startDragging: (id: string, event: ResizeEvent) => void;\n  stopDragging: () => void;\n  unregisterPanel: (id: string) => void;\n} | null>(null);\n\n// Workaround for Parcel scope hoisting (which renames objects/functions).\n// Casting to :any is required to avoid corrupting the generated TypeScript types.\n// See github.com/parcel-bundler/parcel/issues/8724\n(PanelGroupContext as any).displayName = \"PanelGroupContext\";\n","import {\n  createElement,\n  CSSProperties,\n  ElementType,\n  ReactNode,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\nimport { PanelGroupContext } from \"./PanelContexts\";\nimport { Direction, PanelData, PanelGroupOnLayout, ResizeEvent } from \"./types\";\nimport { loadPanelLayout, savePanelGroupLayout } from \"./utils/serialization\";\nimport { getDragOffset, getMovement } from \"./utils/coordinates\";\nimport {\n  adjustByDelta,\n  callPanelCallbacks,\n  getBeforeAndAfterIds,\n  getFlexGrow,\n  getPanelGroup,\n  getResizeHandlePanelIds,\n  panelsMapToSortedArray,\n} from \"./utils/group\";\nimport useIsomorphicLayoutEffect from \"./hooks/useIsomorphicEffect\";\nimport useUniqueId from \"./hooks/useUniqueId\";\nimport { useWindowSplitterPanelGroupBehavior } from \"./hooks/useWindowSplitterBehavior\";\nimport { resetGlobalCursorStyle, setGlobalCursorStyle } from \"./utils/cursor\";\nimport debounce from \"./utils/debounce\";\n\n// Limit the frequency of localStorage updates.\nconst savePanelGroupLayoutDebounced = debounce(savePanelGroupLayout, 100);\n\nexport type CommittedValues = {\n  direction: Direction;\n  panels: Map<string, PanelData>;\n  sizes: number[];\n};\n\nexport type PanelDataMap = Map<string, PanelData>;\n\n// TODO\n// Within an active drag, remember original positions to refine more easily on expand.\n// Look at what the Chrome devtools Sources does.\n\nexport type PanelGroupProps = {\n  autoSaveId?: string;\n  children?: ReactNode;\n  className?: string;\n  direction: Direction;\n  id?: string | null;\n  onLayout?: PanelGroupOnLayout;\n  style?: CSSProperties;\n  tagName?: ElementType;\n};\n\nexport function PanelGroup({\n  autoSaveId,\n  children = null,\n  className: classNameFromProps = \"\",\n  direction,\n  id: idFromProps = null,\n  onLayout = null,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n}: PanelGroupProps) {\n  const groupId = useUniqueId(idFromProps);\n\n  const [activeHandleId, setActiveHandleId] = useState<string | null>(null);\n  const [panels, setPanels] = useState<PanelDataMap>(new Map());\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef<{\n    onLayout: PanelGroupOnLayout | null;\n  }>({ onLayout });\n  useEffect(() => {\n    callbacksRef.current.onLayout = onLayout;\n  });\n\n  // 0-1 values representing the relative size of each panel.\n  const [sizes, setSizes] = useState<number[]>([]);\n\n  // Resize is calculated by the distance between the current pointer event and the resize handle being \"dragged\"\n  // This value accounts for the initial offset when the touch/click starts, so the handle doesn't appear to \"jump\"\n  const dragOffsetRef = useRef<number>(0);\n\n  // Used to support imperative collapse/expand API.\n  const panelSizeBeforeCollapse = useRef<Map<string, number>>(new Map());\n\n  // Store committed values to avoid unnecessarily re-running memoization/effects functions.\n  const committedValuesRef = useRef<CommittedValues>({\n    direction,\n    panels,\n    sizes,\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.panels = panels;\n    committedValuesRef.current.sizes = sizes;\n  });\n\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    groupId,\n    panels,\n    setSizes,\n    sizes,\n    panelSizeBeforeCollapse,\n  });\n\n  // Notify external code when sizes have changed.\n  useEffect(() => {\n    const { onLayout } = callbacksRef.current;\n    if (onLayout) {\n      const { sizes } = committedValuesRef.current;\n\n      // Don't commit layout until all panels have registered and re-rendered with their actual sizes.\n      if (sizes.length > 0) {\n        onLayout(sizes);\n      }\n    }\n  }, [sizes]);\n\n  // Notify Panel listeners about their initial sizes and collapsed state after mount.\n  // Subsequent changes will be called by the resizeHandler.\n  const didNotifyCallbacksAfterMountRef = useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    if (didNotifyCallbacksAfterMountRef.current) {\n      return;\n    }\n\n    const { panels, sizes } = committedValuesRef.current;\n    if (sizes.length > 0) {\n      didNotifyCallbacksAfterMountRef.current = true;\n\n      const panelsArray = panelsMapToSortedArray(panels);\n      callPanelCallbacks(panelsArray, [], sizes);\n    }\n  }, [sizes]);\n\n  // Once all panels have registered themselves,\n  // Compute the initial sizes based on default weights.\n  // This assumes that panels register during initial mount (no conditional rendering)!\n  useIsomorphicLayoutEffect(() => {\n    const sizes = committedValuesRef.current.sizes;\n    if (sizes.length === panels.size) {\n      // Only compute (or restore) default sizes once per panel configuration.\n      return;\n    }\n\n    // If this panel has been configured to persist sizing information,\n    // default size should be restored from local storage if possible.\n    let defaultSizes: number[] | undefined = undefined;\n    if (autoSaveId) {\n      const panelsArray = panelsMapToSortedArray(panels);\n      defaultSizes = loadPanelLayout(autoSaveId, panelsArray);\n    }\n\n    if (defaultSizes != null) {\n      setSizes(defaultSizes);\n    } else {\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      let panelsWithNullDefaultSize = 0;\n      let totalDefaultSize = 0;\n      let totalMinSize = 0;\n\n      // TODO\n      // Implicit default size calculations below do not account for inferred min/max size values.\n      // e.g. if Panel A has a maxSize of 40 then Panels A and B can't both have an implicit default size of 50.\n      // For now, these logic edge cases are left to the user to handle via props.\n\n      panelsArray.forEach((panel) => {\n        totalMinSize += panel.minSize;\n\n        if (panel.defaultSize === null) {\n          panelsWithNullDefaultSize++;\n        } else {\n          totalDefaultSize += panel.defaultSize;\n        }\n      });\n\n      if (totalDefaultSize > 100) {\n        throw new Error(\n          `The sum of the defaultSize of all panels in a group cannot exceed 100.`\n        );\n      } else if (totalMinSize > 100) {\n        throw new Error(\n          `The sum of the minSize of all panels in a group cannot exceed 100.`\n        );\n      }\n\n      setSizes(\n        panelsArray.map((panel) => {\n          if (panel.defaultSize === null) {\n            return (100 - totalDefaultSize) / panelsWithNullDefaultSize;\n          }\n\n          return panel.defaultSize;\n        })\n      );\n    }\n  }, [autoSaveId, panels]);\n\n  useEffect(() => {\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (sizes.length === 0 || sizes.length !== panels.size) {\n        return;\n      }\n\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      savePanelGroupLayoutDebounced(autoSaveId, panelsArray, sizes);\n    }\n  }, [autoSaveId, panels, sizes]);\n\n  const getPanelStyle = useCallback(\n    (id: string): CSSProperties => {\n      const { panels } = committedValuesRef.current;\n\n      // Before mounting, Panels will not yet have registered themselves.\n      // This includes server rendering.\n      // At this point the best we can do is render everything with the same size.\n      if (panels.size === 0) {\n        return {\n          flexBasis: \"auto\",\n          flexGrow: 1,\n          flexShrink: 1,\n\n          // Without this, Panel sizes may be unintentionally overridden by their content.\n          overflow: \"hidden\",\n        };\n      }\n\n      const flexGrow = getFlexGrow(panels, id, sizes);\n\n      return {\n        flexBasis: 0,\n        flexGrow,\n        flexShrink: 1,\n\n        // Without this, Panel sizes may be unintentionally overridden by their content.\n        overflow: \"hidden\",\n\n        // Disable pointer events inside of a panel during resize.\n        // This avoid edge cases like nested iframes.\n        pointerEvents: activeHandleId !== null ? \"none\" : undefined,\n      };\n    },\n    [activeHandleId, direction, sizes]\n  );\n\n  const registerPanel = useCallback((id: string, panel: PanelData) => {\n    setPanels((prevPanels) => {\n      if (prevPanels.has(id)) {\n        return prevPanels;\n      }\n\n      const nextPanels = new Map(prevPanels);\n      nextPanels.set(id, panel);\n\n      return nextPanels;\n    });\n  }, []);\n\n  const registerResizeHandle = useCallback(\n    (handleId: string) => {\n      const resizeHandler = (event: ResizeEvent) => {\n        event.preventDefault();\n\n        const {\n          direction,\n          panels,\n          sizes: prevSizes,\n        } = committedValuesRef.current;\n\n        const panelsArray = panelsMapToSortedArray(panels);\n\n        const [idBefore, idAfter] = getResizeHandlePanelIds(\n          groupId,\n          handleId,\n          panelsArray\n        );\n        if (idBefore == null || idAfter == null) {\n          return;\n        }\n\n        const movement = getMovement(\n          event,\n          groupId,\n          handleId,\n          panelsArray,\n          direction,\n          prevSizes,\n          dragOffsetRef.current\n        );\n        if (movement === 0) {\n          return;\n        }\n\n        const groupElement = getPanelGroup(groupId);\n        const rect = groupElement.getBoundingClientRect();\n        const isHorizontal = direction === \"horizontal\";\n        const size = isHorizontal ? rect.width : rect.height;\n        const delta = (movement / size) * 100;\n\n        const nextSizes = adjustByDelta(\n          event,\n          panels,\n          idBefore,\n          idAfter,\n          delta,\n          prevSizes,\n          panelSizeBeforeCollapse.current\n        );\n        if (prevSizes === nextSizes) {\n          // If the pointer has moved too far to resize the panel any further,\n          // update the cursor style for a visual clue.\n          // This mimics VS Code behavior.\n          if (isHorizontal) {\n            setGlobalCursorStyle(\n              movement < 0 ? \"horizontal-min\" : \"horizontal-max\"\n            );\n          } else {\n            setGlobalCursorStyle(\n              movement < 0 ? \"vertical-min\" : \"vertical-max\"\n            );\n          }\n        } else {\n          // Reset the cursor style to the the normal resize cursor.\n          setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n\n          // If resize change handlers have been declared, this is the time to call them.\n          callPanelCallbacks(panelsArray, prevSizes, nextSizes);\n\n          setSizes(nextSizes);\n        }\n      };\n\n      return resizeHandler;\n    },\n    [groupId]\n  );\n\n  const unregisterPanel = useCallback((id: string) => {\n    setPanels((prevPanels) => {\n      if (!prevPanels.has(id)) {\n        return prevPanels;\n      }\n\n      const nextPanels = new Map(prevPanels);\n      nextPanels.delete(id);\n\n      return nextPanels;\n    });\n  }, []);\n\n  const collapsePanel = useCallback((id: string) => {\n    const { panels, sizes: prevSizes } = committedValuesRef.current;\n\n    const panel = panels.get(id);\n    if (panel == null || !panel.collapsible) {\n      return;\n    }\n\n    const panelsArray = panelsMapToSortedArray(panels);\n\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n\n    const currentSize = prevSizes[index];\n    if (currentSize === 0) {\n      // Panel is already collapsed.\n      return;\n    }\n\n    panelSizeBeforeCollapse.current.set(id, currentSize);\n\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize : 0 - currentSize;\n\n    const nextSizes = adjustByDelta(\n      null,\n      panels,\n      idBefore,\n      idAfter,\n      delta,\n      prevSizes,\n      panelSizeBeforeCollapse.current\n    );\n    if (prevSizes !== nextSizes) {\n      // If resize change handlers have been declared, this is the time to call them.\n      callPanelCallbacks(panelsArray, prevSizes, nextSizes);\n\n      setSizes(nextSizes);\n    }\n  }, []);\n\n  const expandPanel = useCallback((id: string) => {\n    const { panels, sizes: prevSizes } = committedValuesRef.current;\n\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n\n    const sizeBeforeCollapse =\n      panelSizeBeforeCollapse.current.get(id) || panel.minSize;\n    if (!sizeBeforeCollapse) {\n      return;\n    }\n\n    const panelsArray = panelsMapToSortedArray(panels);\n\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n\n    const currentSize = prevSizes[index];\n    if (currentSize !== 0) {\n      // Panel is already expanded.\n      return;\n    }\n\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? 0 - sizeBeforeCollapse : sizeBeforeCollapse;\n\n    const nextSizes = adjustByDelta(\n      null,\n      panels,\n      idBefore,\n      idAfter,\n      delta,\n      prevSizes,\n      panelSizeBeforeCollapse.current\n    );\n    if (prevSizes !== nextSizes) {\n      // If resize change handlers have been declared, this is the time to call them.\n      callPanelCallbacks(panelsArray, prevSizes, nextSizes);\n\n      setSizes(nextSizes);\n    }\n  }, []);\n\n  const resizePanel = useCallback((id: string, nextSize: number) => {\n    const { panels, sizes: prevSizes } = committedValuesRef.current;\n\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n\n    const panelsArray = panelsMapToSortedArray(panels);\n\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n\n    const currentSize = prevSizes[index];\n    if (currentSize === nextSize) {\n      return;\n    }\n\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize - nextSize : nextSize - currentSize;\n\n    const nextSizes = adjustByDelta(\n      null,\n      panels,\n      idBefore,\n      idAfter,\n      delta,\n      prevSizes,\n      panelSizeBeforeCollapse.current\n    );\n    if (prevSizes !== nextSizes) {\n      // If resize change handlers have been declared, this is the time to call them.\n      callPanelCallbacks(panelsArray, prevSizes, nextSizes);\n\n      setSizes(nextSizes);\n    }\n  }, []);\n\n  const context = useMemo(\n    () => ({\n      activeHandleId,\n      collapsePanel,\n      direction,\n      expandPanel,\n      getPanelStyle,\n      groupId,\n      registerPanel,\n      registerResizeHandle,\n      resizePanel,\n      startDragging: (id: string, event: ResizeEvent) => {\n        setActiveHandleId(id);\n\n        dragOffsetRef.current = getDragOffset(event, id, direction);\n      },\n      stopDragging: () => {\n        resetGlobalCursorStyle();\n        setActiveHandleId(null);\n      },\n      unregisterPanel,\n    }),\n    [\n      activeHandleId,\n      collapsePanel,\n      direction,\n      expandPanel,\n      getPanelStyle,\n      groupId,\n      registerPanel,\n      registerResizeHandle,\n      resizePanel,\n      unregisterPanel,\n    ]\n  );\n\n  const style: CSSProperties = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\",\n  };\n\n  return createElement(PanelGroupContext.Provider, {\n    children: createElement(Type, {\n      children,\n      className: classNameFromProps,\n      \"data-panel-group-direction\": direction,\n      \"data-panel-group-id\": groupId,\n      style: { ...style, ...styleFromProps },\n    }),\n    value: context,\n  });\n}\n\n// Workaround for Parcel scope hoisting (which renames objects/functions).\n// Casting to :any is required to avoid corrupting the generated TypeScript types.\n// See github.com/parcel-bundler/parcel/issues/8724\n(PanelGroup as any).displayName = \"PanelGroup\";\n","import { PanelData } from \"../types\";\n\ntype SerializedPanelGroupState = { [panelIds: string]: number[] };\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using an attribute like minSize instead should work well enough.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels: PanelData[]): string {\n  return panels\n    .map((panel) => {\n      const { minSize, order } = panel;\n      return order ? `${order}:${minSize}` : `${minSize}`;\n    })\n    .sort((a, b) => a.localeCompare(b))\n    .join(\",\");\n}\n\nfunction loadSerializedPanelGroupState(\n  autoSaveId: string\n): SerializedPanelGroupState | null {\n  try {\n    const serialized = localStorage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n\n  return null;\n}\n\nexport function loadPanelLayout(\n  autoSaveId: string,\n  panels: PanelData[]\n): number[] | null {\n  const state = loadSerializedPanelGroupState(autoSaveId);\n  if (state) {\n    const key = getSerializationKey(panels);\n    return state[key] || null;\n  }\n\n  return null;\n}\n\nexport function savePanelGroupLayout(\n  autoSaveId: string,\n  panels: PanelData[],\n  sizes: number[]\n): void {\n  const key = getSerializationKey(panels);\n  const state = loadSerializedPanelGroupState(autoSaveId) || {};\n  state[key] = sizes;\n\n  try {\n    localStorage.setItem(\n      `PanelGroup:sizes:${autoSaveId}`,\n      JSON.stringify(state)\n    );\n  } catch (error) {\n    console.error(error);\n  }\n}\n","import { PRECISION } from \"../constants\";\nimport { Direction, PanelData, ResizeEvent } from \"../types\";\nimport {\n  getPanelGroup,\n  getResizeHandle,\n  getResizeHandlePanelIds,\n} from \"./group\";\n\nexport type Coordinates = {\n  movement: number;\n  offset: number;\n};\n\nexport type Size = {\n  height: number;\n  width: number;\n};\n\nexport function getDragOffset(\n  event: ResizeEvent,\n  handleId: string,\n  direction: Direction,\n  initialOffset: number = 0\n): number {\n  const isHorizontal = direction === \"horizontal\";\n\n  let pointerOffset = 0;\n  if (isMouseEvent(event)) {\n    pointerOffset = isHorizontal ? event.clientX : event.clientY;\n  } else if (isTouchEvent(event)) {\n    const firstTouch = event.touches[0];\n    pointerOffset = isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    return 0;\n  }\n\n  const handleElement = getResizeHandle(handleId);\n  const rect = handleElement.getBoundingClientRect();\n  const elementOffset = isHorizontal ? rect.left : rect.top;\n\n  return pointerOffset - elementOffset - initialOffset;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nexport function getMovement(\n  event: ResizeEvent,\n  groupId: string,\n  handleId: string,\n  panelsArray: PanelData[],\n  direction: Direction,\n  sizes: number[],\n  initialOffset: number\n): number {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n\n    const groupElement = getPanelGroup(groupId);\n    const rect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n\n    const denominator = event.shiftKey ? 10 : 100;\n    const delta = groupSizeInPixels / denominator;\n\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = groupSizeInPixels;\n        break;\n      case \"Home\":\n        movement = -groupSizeInPixels;\n        break;\n    }\n\n    // If the Panel being resized is collapsible,\n    // we need to special case resizing around the minSize boundary.\n    // If contracting, Panels should shrink to their minSize and then snap to fully collapsed.\n    // If expanding from collapsed, they should snap back to their minSize.\n    const [idBefore, idAfter] = getResizeHandlePanelIds(\n      groupId,\n      handleId,\n      panelsArray\n    );\n    const targetPanelId = movement < 0 ? idBefore : idAfter;\n    const targetPanelIndex = panelsArray.findIndex(\n      (panel) => panel.id === targetPanelId\n    );\n    const targetPanel = panelsArray[targetPanelIndex];\n    if (targetPanel.collapsible) {\n      const prevSize = sizes[targetPanelIndex];\n      if (\n        prevSize === 0 ||\n        prevSize.toPrecision(PRECISION) ===\n          targetPanel.minSize.toPrecision(PRECISION)\n      ) {\n        movement =\n          movement < 0\n            ? -targetPanel.minSize * groupSizeInPixels\n            : targetPanel.minSize * groupSizeInPixels;\n      }\n    }\n\n    return movement;\n  } else {\n    return getDragOffset(event, handleId, direction, initialOffset);\n  }\n}\n\nexport function isKeyDown(event: ResizeEvent): event is KeyboardEvent {\n  return event.type === \"keydown\";\n}\n\nexport function isMouseEvent(event: ResizeEvent): event is MouseEvent {\n  return event.type.startsWith(\"mouse\");\n}\n\nexport function isTouchEvent(event: ResizeEvent): event is TouchEvent {\n  return event.type.startsWith(\"touch\");\n}\n","export const PRECISION = 10;\n","import { PRECISION } from \"../constants\";\nimport { PanelData, ResizeEvent } from \"../types\";\n\nexport function adjustByDelta(\n  event: ResizeEvent | null,\n  panels: Map<string, PanelData>,\n  idBefore: string,\n  idAfter: string,\n  delta: number,\n  prevSizes: number[],\n  panelSizeBeforeCollapse: Map<string, number>\n): number[] {\n  if (delta === 0) {\n    return prevSizes;\n  }\n\n  const panelsArray = panelsMapToSortedArray(panels);\n\n  const nextSizes = prevSizes.concat();\n\n  let deltaApplied = 0;\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel immediately after the resizer should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel immediately before the resizer should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resizer.\n\n  // Max-bounds check the panel being expanded first.\n  {\n    const pivotId = delta < 0 ? idAfter : idBefore;\n    const index = panelsArray.findIndex((panel) => panel.id === pivotId);\n    const panel = panelsArray[index];\n    const prevSize = prevSizes[index];\n\n    const nextSize = safeResizePanel(panel, Math.abs(delta), prevSize, event);\n    if (prevSize === nextSize) {\n      return prevSizes;\n    } else {\n      if (nextSize === 0 && prevSize > 0) {\n        panelSizeBeforeCollapse.set(pivotId, prevSize);\n      }\n\n      delta = delta < 0 ? prevSize - nextSize : nextSize - prevSize;\n    }\n  }\n\n  let pivotId = delta < 0 ? idBefore : idAfter;\n  let index = panelsArray.findIndex((panel) => panel.id === pivotId);\n  while (true) {\n    const panel = panelsArray[index];\n    const prevSize = prevSizes[index];\n\n    const nextSize = safeResizePanel(\n      panel,\n      0 - Math.abs(delta),\n      prevSize,\n      event\n    );\n    if (prevSize !== nextSize) {\n      if (nextSize === 0 && prevSize > 0) {\n        panelSizeBeforeCollapse.set(panel.id, prevSize);\n      }\n\n      deltaApplied += prevSize - nextSize;\n\n      nextSizes[index] = nextSize;\n\n      if (deltaApplied.toPrecision(PRECISION) >= delta.toPrecision(PRECISION)) {\n        break;\n      }\n    }\n\n    if (delta < 0) {\n      if (--index < 0) {\n        break;\n      }\n    } else {\n      if (++index >= panelsArray.length) {\n        break;\n      }\n    }\n  }\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore the \"mousemove\" event.\n  if (deltaApplied === 0) {\n    return prevSizes;\n  }\n\n  // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n  pivotId = delta < 0 ? idAfter : idBefore;\n  index = panelsArray.findIndex((panel) => panel.id === pivotId);\n  nextSizes[index] = prevSizes[index] + deltaApplied;\n\n  return nextSizes;\n}\n\nexport function callPanelCallbacks(\n  panelsArray: PanelData[],\n  prevSizes: number[],\n  nextSizes: number[]\n) {\n  nextSizes.forEach((nextSize, index) => {\n    const prevSize = prevSizes[index];\n    if (prevSize !== nextSize) {\n      const { callbacksRef, collapsible } = panelsArray[index];\n      const { onCollapse, onResize } = callbacksRef.current;\n\n      if (onResize) {\n        onResize(nextSize);\n      }\n\n      if (collapsible && onCollapse) {\n        // Falsy check handles both previous size of 0\n        // and initial size of undefined (when mounting)\n        if (!prevSize && nextSize !== 0) {\n          onCollapse(false);\n        } else if (prevSize !== 0 && nextSize === 0) {\n          onCollapse(true);\n        }\n      }\n    }\n  });\n}\n\nexport function getBeforeAndAfterIds(\n  id: string,\n  panelsArray: PanelData[]\n): [idBefore: string | null, idAFter: string | null] {\n  if (panelsArray.length < 2) {\n    return [null, null];\n  }\n\n  const index = panelsArray.findIndex((panel) => panel.id === id);\n  if (index < 0) {\n    return [null, null];\n  }\n\n  const isLastPanel = index === panelsArray.length - 1;\n  const idBefore = isLastPanel ? panelsArray[index - 1].id : id;\n  const idAfter = isLastPanel ? id : panelsArray[index + 1].id;\n\n  return [idBefore, idAfter];\n}\n\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nexport function getFlexGrow(\n  panels: Map<string, PanelData>,\n  id: string,\n  sizes: number[]\n): string {\n  if (panels.size === 1) {\n    return \"100\";\n  }\n\n  const panelsArray = panelsMapToSortedArray(panels);\n\n  const index = panelsArray.findIndex((panel) => panel.id === id);\n  const size = sizes[index];\n  if (size == null) {\n    return \"0\";\n  }\n\n  return size.toPrecision(PRECISION);\n}\n\nexport function getPanel(id: string): HTMLDivElement | null {\n  const element = document.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element as HTMLDivElement;\n  }\n  return null;\n}\n\nexport function getPanelGroup(id: string): HTMLDivElement | null {\n  const element = document.querySelector(`[data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element as HTMLDivElement;\n  }\n  return null;\n}\n\nexport function getResizeHandle(id: string): HTMLDivElement | null {\n  const element = document.querySelector(\n    `[data-panel-resize-handle-id=\"${id}\"]`\n  );\n  if (element) {\n    return element as HTMLDivElement;\n  }\n  return null;\n}\n\nexport function getResizeHandleIndex(id: string): number | null {\n  const handles = getResizeHandles();\n  const index = handles.findIndex(\n    (handle) => handle.getAttribute(\"data-panel-resize-handle-id\") === id\n  );\n  return index || null;\n}\n\nexport function getResizeHandles(): HTMLDivElement[] {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id]`));\n}\n\nexport function getResizeHandlesForGroup(groupId: string): HTMLDivElement[] {\n  return Array.from(\n    document.querySelectorAll(\n      `[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`\n    )\n  );\n}\n\nexport function getResizeHandlePanelIds(\n  groupId: string,\n  handleId: string,\n  panelsArray: PanelData[]\n): [idBefore: string | null, idAfter: string | null] {\n  const handle = getResizeHandle(handleId);\n  const handles = getResizeHandlesForGroup(groupId);\n  const index = handles.indexOf(handle);\n\n  const idBefore: string | null = panelsArray[index]?.id || null;\n  const idAfter: string | null = panelsArray[index + 1]?.id || null;\n\n  return [idBefore, idAfter];\n}\n\nexport function panelsMapToSortedArray(\n  panels: Map<string, PanelData>\n): PanelData[] {\n  return Array.from(panels.values()).sort((a, b) => a.order - b.order);\n}\n\nfunction safeResizePanel(\n  panel: PanelData,\n  delta: number,\n  prevSize: number,\n  event: ResizeEvent | null\n): number {\n  const nextSizeUnsafe = prevSize + delta;\n\n  if (panel.collapsible) {\n    if (prevSize > 0) {\n      if (nextSizeUnsafe <= 0) {\n        return 0;\n      }\n    } else {\n      const isKeyboardEvent = event?.type?.startsWith(\"key\");\n      if (!isKeyboardEvent) {\n        // Keyboard events should expand a collapsed panel to the min size,\n        // but mouse events should wait until the panel has reached its min size\n        // to avoid a visual flickering when dragging between collapsed and min size.\n        if (nextSizeUnsafe < panel.minSize) {\n          return 0;\n        }\n      }\n    }\n  }\n\n  const nextSize = Math.min(\n    panel.maxSize,\n    Math.max(panel.minSize, nextSizeUnsafe)\n  );\n\n  return nextSize;\n}\n","import { RefObject, useEffect } from \"react\";\nimport { PRECISION } from \"../constants\";\n\nimport { CommittedValues, PanelDataMap } from \"../PanelGroup\";\nimport { ResizeHandler } from \"../types\";\nimport {\n  adjustByDelta,\n  getPanel,\n  getPanelGroup,\n  getResizeHandle,\n  getResizeHandleIndex,\n  getResizeHandlePanelIds,\n  getResizeHandles,\n  getResizeHandlesForGroup,\n  getFlexGrow,\n  panelsMapToSortedArray,\n} from \"../utils/group\";\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nexport function useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  groupId,\n  panels,\n  setSizes,\n  sizes,\n  panelSizeBeforeCollapse,\n}: {\n  committedValuesRef: RefObject<CommittedValues>;\n  groupId: string;\n  panels: PanelDataMap;\n  setSizes: (sizes: number[]) => void;\n  sizes: number[];\n  panelSizeBeforeCollapse: RefObject<Map<string, number>>;\n}): void {\n  useEffect(() => {\n    const { direction, panels } = committedValuesRef.current;\n\n    const groupElement = getPanelGroup(groupId);\n    const { height, width } = groupElement.getBoundingClientRect();\n\n    const handles = getResizeHandlesForGroup(groupId);\n    const cleanupFunctions = handles.map((handle) => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      const [idBefore, idAfter] = getResizeHandlePanelIds(\n        groupId,\n        handleId,\n        panelsArray\n      );\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n\n      let minSize = 0;\n      let maxSize = 100;\n      let totalMinSize = 0;\n      let totalMaxSize = 0;\n\n      // A panel's effective min/max sizes also need to account for other panel's sizes.\n      panelsArray.forEach((panelData) => {\n        if (panelData.id === idBefore) {\n          maxSize = panelData.maxSize;\n          minSize = panelData.minSize;\n        } else {\n          totalMinSize += panelData.minSize;\n          totalMaxSize += panelData.maxSize;\n        }\n      });\n\n      const ariaValueMax = Math.min(maxSize, 100 - totalMinSize);\n      const ariaValueMin = Math.max(\n        minSize,\n        (panelsArray.length - 1) * 100 - totalMaxSize\n      );\n\n      const flexGrow = getFlexGrow(panels, idBefore, sizes);\n\n      handle.setAttribute(\"aria-valuemax\", \"\" + Math.round(ariaValueMax));\n      handle.setAttribute(\"aria-valuemin\", \"\" + Math.round(ariaValueMin));\n      handle.setAttribute(\"aria-valuenow\", \"\" + Math.round(parseInt(flexGrow)));\n\n      const onKeyDown = (event: KeyboardEvent) => {\n        switch (event.key) {\n          case \"Enter\": {\n            const index = panelsArray.findIndex(\n              (panel) => panel.id === idBefore\n            );\n            if (index >= 0) {\n              const panelData = panelsArray[index];\n              const size = sizes[index];\n              if (size != null) {\n                let delta = 0;\n                if (\n                  size.toPrecision(PRECISION) <=\n                  panelData.minSize.toPrecision(PRECISION)\n                ) {\n                  delta = direction === \"horizontal\" ? width : height;\n                } else {\n                  delta = -(direction === \"horizontal\" ? width : height);\n                }\n\n                const nextSizes = adjustByDelta(\n                  event,\n                  panels,\n                  idBefore,\n                  idAfter,\n                  delta,\n                  sizes,\n                  panelSizeBeforeCollapse.current\n                );\n                if (sizes !== nextSizes) {\n                  setSizes(nextSizes);\n                }\n              }\n            }\n            break;\n          }\n        }\n      };\n\n      handle.addEventListener(\"keydown\", onKeyDown);\n\n      const panelBefore = getPanel(idBefore);\n      if (panelBefore != null) {\n        handle.setAttribute(\"aria-controls\", panelBefore.id);\n      }\n\n      return () => {\n        handle.removeAttribute(\"aria-valuemax\");\n        handle.removeAttribute(\"aria-valuemin\");\n        handle.removeAttribute(\"aria-valuenow\");\n\n        handle.removeEventListener(\"keydown\", onKeyDown);\n\n        if (panelBefore != null) {\n          handle.removeAttribute(\"aria-controls\");\n        }\n      };\n    });\n\n    return () => {\n      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());\n    };\n  }, [groupId, panels, sizes]);\n}\n\nexport function useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n}: {\n  disabled: boolean;\n  handleId: string;\n  resizeHandler: ResizeHandler | null;\n}): void {\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n\n    const handleElement = getResizeHandle(handleId);\n    if (handleElement == null) {\n      return;\n    }\n\n    const onKeyDown = (event: KeyboardEvent) => {\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\": {\n          resizeHandler(event);\n          break;\n        }\n        case \"F6\": {\n          const handles = getResizeHandles();\n          const index = getResizeHandleIndex(handleId);\n\n          const nextIndex = event.shiftKey\n            ? index > 0\n              ? index - 1\n              : handles.length - 1\n            : index + 1 < handles.length\n            ? index + 1\n            : 0;\n\n          const nextHandle = handles[nextIndex] as HTMLDivElement;\n          nextHandle.focus();\n\n          break;\n        }\n      }\n    };\n\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [disabled, handleId, resizeHandler]);\n}\n","type CursorState =\n  | \"horizontal\"\n  | \"horizontal-max\"\n  | \"horizontal-min\"\n  | \"vertical\"\n  | \"vertical-max\"\n  | \"vertical-min\";\n\nlet currentState: CursorState | null = null;\nlet element: HTMLStyleElement | null = null;\n\nexport function getCursorStyle(state: CursorState): string {\n  switch (state) {\n    case \"horizontal\":\n      return \"col-resize\";\n    case \"horizontal-max\":\n      return \"w-resize\";\n    case \"horizontal-min\":\n      return \"e-resize\";\n    case \"vertical\":\n      return \"row-resize\";\n    case \"vertical-max\":\n      return \"n-resize\";\n    case \"vertical-min\":\n      return \"s-resize\";\n  }\n}\n\nexport function resetGlobalCursorStyle() {\n  if (element !== null) {\n    document.head.removeChild(element);\n\n    currentState = null;\n    element = null;\n  }\n}\n\nexport function setGlobalCursorStyle(state: CursorState) {\n  if (currentState === state) {\n    return;\n  }\n\n  currentState = state;\n\n  const style = getCursorStyle(state);\n\n  if (element === null) {\n    element = document.createElement(\"style\");\n\n    document.head.appendChild(element);\n  }\n\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n","export default function debounce<T extends Function>(\n  callback: T,\n  durationMs: number = 10\n) {\n  let timeoutId: NodeJS.Timeout | null = null;\n\n  let callable = (...args: any) => {\n    clearTimeout(timeoutId);\n\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n\n  return callable as unknown as T;\n}\n","import {\n  createElement,\n  CSSProperties,\n  ElementType,\n  MouseEvent,\n  ReactNode,\n  TouchEvent,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport useUniqueId from \"./hooks/useUniqueId\";\n\nimport { useWindowSplitterResizeHandlerBehavior } from \"./hooks/useWindowSplitterBehavior\";\nimport { PanelGroupContext } from \"./PanelContexts\";\nimport type { ResizeHandler, ResizeEvent } from \"./types\";\nimport { getCursorStyle } from \"./utils/cursor\";\n\nexport type PanelResizeHandleProps = {\n  children?: ReactNode;\n  className?: string;\n  disabled?: boolean;\n  id?: string | null;\n  style?: CSSProperties;\n  tagName?: ElementType;\n};\n\nexport function PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  id: idFromProps = null,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n}: PanelResizeHandleProps) {\n  const divElementRef = useRef<HTMLDivElement>(null);\n\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(\n      `PanelResizeHandle components must be rendered within a PanelGroup container`\n    );\n  }\n\n  const {\n    activeHandleId,\n    direction,\n    groupId,\n    registerResizeHandle,\n    startDragging,\n    stopDragging,\n  } = panelGroupContext;\n\n  const resizeHandleId = useUniqueId(idFromProps);\n  const isDragging = activeHandleId === resizeHandleId;\n\n  const [isFocused, setIsFocused] = useState(false);\n\n  const [resizeHandler, setResizeHandler] = useState<ResizeHandler | null>(\n    null\n  );\n\n  const stopDraggingAndBlur = useCallback(() => {\n    // Clicking on the drag handle shouldn't leave it focused;\n    // That would cause the PanelGroup to think it was still active.\n    const div = divElementRef.current!;\n    div.blur();\n\n    stopDragging();\n  }, [stopDragging]);\n\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandle(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandle]);\n\n  useEffect(() => {\n    if (disabled || resizeHandler == null || !isDragging) {\n      return;\n    }\n\n    const onMove = (event: ResizeEvent) => {\n      resizeHandler(event);\n    };\n\n    document.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n    document.body.addEventListener(\"mousemove\", onMove);\n    document.body.addEventListener(\"touchmove\", onMove);\n    window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n    window.addEventListener(\"touchend\", stopDraggingAndBlur);\n\n    return () => {\n      document.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n      document.body.removeEventListener(\"mousemove\", onMove);\n      document.body.removeEventListener(\"touchmove\", onMove);\n      window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n      window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n    };\n  }, [direction, disabled, isDragging, resizeHandler, stopDraggingAndBlur]);\n\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n  });\n\n  const style: CSSProperties = {\n    cursor: getCursorStyle(direction),\n    touchAction: \"none\",\n    userSelect: \"none\",\n  };\n\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-resize-handle-active\": isDragging\n      ? \"pointer\"\n      : isFocused\n      ? \"keyboard\"\n      : undefined,\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    onMouseDown: (event: MouseEvent) =>\n      startDragging(resizeHandleId, event.nativeEvent),\n    onMouseUp: stopDraggingAndBlur,\n    onTouchCancel: stopDraggingAndBlur,\n    onTouchEnd: stopDraggingAndBlur,\n    onTouchStart: (event: TouchEvent) =>\n      startDragging(resizeHandleId, event.nativeEvent),\n    ref: divElementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps,\n    },\n    tabIndex: 0,\n  });\n}\n\n// Workaround for Parcel scope hoisting (which renames objects/functions).\n// Casting to :any is required to avoid corrupting the generated TypeScript types.\n// See github.com/parcel-bundler/parcel/issues/8724\n(PanelResizeHandle as any).displayName = \"PanelResizeHandle\";\n"],"names":[],"version":3,"file":"react-resizable-panels.js.map"}
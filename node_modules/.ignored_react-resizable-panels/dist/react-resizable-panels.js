var $b2QPe$react = require("react");

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "Panel", () => $4b51bd7b90b9da8b$export$2ddb90ad54e5f587);
$parcel$export(module.exports, "PanelGroup", () => $19bf0050f73d236b$export$1d05749f6f573bb);
$parcel$export(module.exports, "PanelResizeHandle", () => $01377e07790cf46f$export$8829ecf6b6b15484);


const $967abed3d1bd1fe9$var$canUseEffectHooks = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const $967abed3d1bd1fe9$var$useIsomorphicLayoutEffect = $967abed3d1bd1fe9$var$canUseEffectHooks ? (0, $b2QPe$react.useLayoutEffect) : ()=>{};
var $967abed3d1bd1fe9$export$2e2bcd8739ae039 = $967abed3d1bd1fe9$var$useIsomorphicLayoutEffect;



let $6d548a0d130941e3$var$counter = 0;
function $6d548a0d130941e3$export$2e2bcd8739ae039(idFromParams = null) {
    const idFromUseId = typeof (0, $b2QPe$react.useId) === "function" ? (0, $b2QPe$react.useId)() : null;
    const idRef = (0, $b2QPe$react.useRef)(idFromParams || idFromUseId || null);
    if (idRef.current === null) idRef.current = "" + $6d548a0d130941e3$var$counter++;
    return idRef.current;
}



const $3251d17c1c3bce6c$export$7d8c6d083caec74a = (0, $b2QPe$react.createContext)(null);
// Workaround for Parcel scope hoisting (which renames objects/functions).
// Casting to :any is required to avoid corrupting the generated TypeScript types.
// See github.com/parcel-bundler/parcel/issues/8724
$3251d17c1c3bce6c$export$7d8c6d083caec74a.displayName = "PanelGroupContext";


function $4b51bd7b90b9da8b$var$PanelWithForwardedRef({ children: children = null , className: classNameFromProps = "" , collapsible: collapsible = false , defaultSize: defaultSize = null , forwardedRef: forwardedRef , id: idFromProps = null , maxSize: maxSize = 100 , minSize: minSize = 10 , onCollapse: onCollapse = null , onResize: onResize = null , order: order = null , style: styleFromProps = {} , tagName: Type = "div"  }) {
    const context = (0, $b2QPe$react.useContext)((0, $3251d17c1c3bce6c$export$7d8c6d083caec74a));
    if (context === null) throw Error(`Panel components must be rendered within a PanelGroup container`);
    const panelId = (0, $6d548a0d130941e3$export$2e2bcd8739ae039)(idFromProps);
    const { collapsePanel: collapsePanel , expandPanel: expandPanel , getPanelStyle: getPanelStyle , registerPanel: registerPanel , resizePanel: resizePanel , unregisterPanel: unregisterPanel  } = context;
    // Use a ref to guard against users passing inline props
    const callbacksRef = (0, $b2QPe$react.useRef)({
        onCollapse: onCollapse,
        onResize: onResize
    });
    (0, $b2QPe$react.useEffect)(()=>{
        callbacksRef.current.onCollapse = onCollapse;
        callbacksRef.current.onResize = onResize;
    });
    // Basic props validation
    if (minSize < 0 || minSize > 100) throw Error(`Panel minSize must be between 0 and 100, but was ${minSize}`);
    else if (maxSize < 0 || maxSize > 100) throw Error(`Panel maxSize must be between 0 and 100, but was ${maxSize}`);
    else if (defaultSize !== null) {
        if (defaultSize < 0 || defaultSize > 100) throw Error(`Panel defaultSize must be between 0 and 100, but was ${defaultSize}`);
        else if (minSize > defaultSize && !collapsible) {
            console.error(`Panel minSize ${minSize} cannot be greater than defaultSize ${defaultSize}`);
            defaultSize = minSize;
        }
    }
    (0, $967abed3d1bd1fe9$export$2e2bcd8739ae039)(()=>{
        const panel = {
            callbacksRef: callbacksRef,
            collapsible: collapsible,
            defaultSize: defaultSize,
            id: panelId,
            maxSize: maxSize,
            minSize: minSize,
            order: order
        };
        registerPanel(panelId, panel);
        return ()=>{
            unregisterPanel(panelId);
        };
    }, [
        collapsible,
        defaultSize,
        panelId,
        maxSize,
        minSize,
        order,
        registerPanel,
        unregisterPanel
    ]);
    const style = getPanelStyle(panelId);
    const committedValuesRef = (0, $b2QPe$react.useRef)({
        size: $4b51bd7b90b9da8b$var$parseSizeFromStyle(style)
    });
    (0, $967abed3d1bd1fe9$export$2e2bcd8739ae039)(()=>{
        committedValuesRef.current.size = $4b51bd7b90b9da8b$var$parseSizeFromStyle(style);
    });
    (0, $b2QPe$react.useImperativeHandle)(forwardedRef, ()=>({
            collapse: ()=>collapsePanel(panelId),
            expand: ()=>expandPanel(panelId),
            getCollapsed () {
                return committedValuesRef.current.size === 0;
            },
            getSize () {
                return committedValuesRef.current.size;
            },
            resize: (percentage)=>resizePanel(panelId, percentage)
        }), [
        collapsePanel,
        expandPanel,
        panelId,
        resizePanel
    ]);
    return (0, $b2QPe$react.createElement)(Type, {
        children: children,
        className: classNameFromProps,
        "data-panel": "",
        "data-panel-collapsible": collapsible || undefined,
        "data-panel-id": panelId,
        "data-panel-size": parseFloat("" + style.flexGrow).toFixed(1),
        id: `data-panel-id-${panelId}`,
        style: {
            ...style,
            ...styleFromProps
        }
    });
}
const $4b51bd7b90b9da8b$export$2ddb90ad54e5f587 = (0, $b2QPe$react.forwardRef)((props, ref)=>(0, $b2QPe$react.createElement)($4b51bd7b90b9da8b$var$PanelWithForwardedRef, {
        ...props,
        forwardedRef: ref
    }));
// Workaround for Parcel scope hoisting (which renames objects/functions).
// Casting to :any is required to avoid corrupting the generated TypeScript types.
// See github.com/parcel-bundler/parcel/issues/8724
$4b51bd7b90b9da8b$var$PanelWithForwardedRef.displayName = "Panel";
$4b51bd7b90b9da8b$export$2ddb90ad54e5f587.displayName = "forwardRef(Panel)";
// HACK
function $4b51bd7b90b9da8b$var$parseSizeFromStyle(style) {
    const { flexGrow: flexGrow  } = style;
    if (typeof flexGrow === "string") return parseFloat(flexGrow);
    else return flexGrow;
}




// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)
// so they should not be used as part of the serialization key.
// Using an attribute like minSize instead should work well enough.
// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.
function $e045b0dd313f33c7$var$getSerializationKey(panels) {
    return panels.map((panel)=>{
        const { minSize: minSize , order: order  } = panel;
        return order ? `${order}:${minSize}` : `${minSize}`;
    }).sort((a, b)=>a.localeCompare(b)).join(",");
}
function $e045b0dd313f33c7$var$loadSerializedPanelGroupState(autoSaveId) {
    try {
        const serialized = localStorage.getItem(`PanelGroup:sizes:${autoSaveId}`);
        if (serialized) {
            const parsed = JSON.parse(serialized);
            if (typeof parsed === "object" && parsed != null) return parsed;
        }
    } catch (error) {}
    return null;
}
function $e045b0dd313f33c7$export$9c80c6617f0386da(autoSaveId, panels) {
    const state = $e045b0dd313f33c7$var$loadSerializedPanelGroupState(autoSaveId);
    if (state) {
        const key = $e045b0dd313f33c7$var$getSerializationKey(panels);
        return state[key] || null;
    }
    return null;
}
function $e045b0dd313f33c7$export$af183b313c61be4f(autoSaveId, panels, sizes) {
    const key = $e045b0dd313f33c7$var$getSerializationKey(panels);
    const state = $e045b0dd313f33c7$var$loadSerializedPanelGroupState(autoSaveId) || {};
    state[key] = sizes;
    try {
        localStorage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));
    } catch (error) {
        console.error(error);
    }
}


const $3237bc4a138172cd$export$d6d3992f3becc879 = 10;



function $d520236daad9c5d5$export$f50bae335f53943c(event, panels, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse) {
    if (delta === 0) return prevSizes;
    const panelsArray = $d520236daad9c5d5$export$a861c0ad45885494(panels);
    const nextSizes = prevSizes.concat();
    let deltaApplied = 0;
    // A resizing panel affects the panels before or after it.
    //
    // A negative delta means the panel immediately after the resizer should grow/expand by decreasing its offset.
    // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.
    //
    // A positive delta means the panel immediately before the resizer should "expand".
    // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resizer.
    // Max-bounds check the panel being expanded first.
    {
        const pivotId = delta < 0 ? idAfter : idBefore;
        const index = panelsArray.findIndex((panel)=>panel.id === pivotId);
        const panel = panelsArray[index];
        const prevSize = prevSizes[index];
        const nextSize = $d520236daad9c5d5$var$safeResizePanel(panel, Math.abs(delta), prevSize, event);
        if (prevSize === nextSize) return prevSizes;
        else {
            if (nextSize === 0 && prevSize > 0) panelSizeBeforeCollapse.set(pivotId, prevSize);
            delta = delta < 0 ? prevSize - nextSize : nextSize - prevSize;
        }
    }
    let pivotId1 = delta < 0 ? idBefore : idAfter;
    let index1 = panelsArray.findIndex((panel)=>panel.id === pivotId1);
    while(true){
        const panel1 = panelsArray[index1];
        const prevSize1 = prevSizes[index1];
        const nextSize1 = $d520236daad9c5d5$var$safeResizePanel(panel1, 0 - Math.abs(delta), prevSize1, event);
        if (prevSize1 !== nextSize1) {
            if (nextSize1 === 0 && prevSize1 > 0) panelSizeBeforeCollapse.set(panel1.id, prevSize1);
            deltaApplied += prevSize1 - nextSize1;
            nextSizes[index1] = nextSize1;
            if (deltaApplied.toPrecision((0, $3237bc4a138172cd$export$d6d3992f3becc879)) >= delta.toPrecision((0, $3237bc4a138172cd$export$d6d3992f3becc879))) break;
        }
        if (delta < 0) {
            if (--index1 < 0) break;
        } else {
            if (++index1 >= panelsArray.length) break;
        }
    }
    // If we were unable to resize any of the panels panels, return the previous state.
    // This will essentially bailout and ignore the "mousemove" event.
    if (deltaApplied === 0) return prevSizes;
    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.
    pivotId1 = delta < 0 ? idAfter : idBefore;
    index1 = panelsArray.findIndex((panel)=>panel.id === pivotId1);
    nextSizes[index1] = prevSizes[index1] + deltaApplied;
    return nextSizes;
}
function $d520236daad9c5d5$export$b8e48269e4faa934(panelsArray, prevSizes, nextSizes) {
    nextSizes.forEach((nextSize, index)=>{
        const prevSize = prevSizes[index];
        if (prevSize !== nextSize) {
            const { callbacksRef: callbacksRef , collapsible: collapsible  } = panelsArray[index];
            const { onCollapse: onCollapse , onResize: onResize  } = callbacksRef.current;
            if (onResize) onResize(nextSize);
            if (collapsible && onCollapse) {
                // Falsy check handles both previous size of 0
                // and initial size of undefined (when mounting)
                if (!prevSize && nextSize !== 0) onCollapse(false);
                else if (prevSize !== 0 && nextSize === 0) onCollapse(true);
            }
        }
    });
}
function $d520236daad9c5d5$export$5a5b0c1d38c23c3b(id, panelsArray) {
    if (panelsArray.length < 2) return [
        null,
        null
    ];
    const index = panelsArray.findIndex((panel)=>panel.id === id);
    if (index < 0) return [
        null,
        null
    ];
    const isLastPanel = index === panelsArray.length - 1;
    const idBefore = isLastPanel ? panelsArray[index - 1].id : id;
    const idAfter = isLastPanel ? id : panelsArray[index + 1].id;
    return [
        idBefore,
        idAfter
    ];
}
function $d520236daad9c5d5$export$6f43503e166de6fb(panels, id, sizes) {
    if (panels.size === 1) return "100";
    const panelsArray = $d520236daad9c5d5$export$a861c0ad45885494(panels);
    const index = panelsArray.findIndex((panel)=>panel.id === id);
    const size = sizes[index];
    if (size == null) return "0";
    return size.toPrecision((0, $3237bc4a138172cd$export$d6d3992f3becc879));
}
function $d520236daad9c5d5$export$7361ed18ff57179e(id) {
    const element = document.querySelector(`[data-panel-id="${id}"]`);
    if (element) return element;
    return null;
}
function $d520236daad9c5d5$export$5e67632cf3550a9c(id) {
    const element = document.querySelector(`[data-panel-group-id="${id}"]`);
    if (element) return element;
    return null;
}
function $d520236daad9c5d5$export$2e27d3a347680388(id) {
    const element = document.querySelector(`[data-panel-resize-handle-id="${id}"]`);
    if (element) return element;
    return null;
}
function $d520236daad9c5d5$export$96a40be80fb6c3c8(id) {
    const handles = $d520236daad9c5d5$export$8d0cd3c32ddc045e();
    const index = handles.findIndex((handle)=>handle.getAttribute("data-panel-resize-handle-id") === id);
    return index || null;
}
function $d520236daad9c5d5$export$8d0cd3c32ddc045e() {
    return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id]`));
}
function $d520236daad9c5d5$export$ae14931f0a0256a3(groupId) {
    return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${groupId}"]`));
}
function $d520236daad9c5d5$export$68d3a33c21dfbe27(groupId, handleId, panelsArray) {
    const handle = $d520236daad9c5d5$export$2e27d3a347680388(handleId);
    const handles = $d520236daad9c5d5$export$ae14931f0a0256a3(groupId);
    const index = handles.indexOf(handle);
    const idBefore = panelsArray[index]?.id || null;
    const idAfter = panelsArray[index + 1]?.id || null;
    return [
        idBefore,
        idAfter
    ];
}
function $d520236daad9c5d5$export$a861c0ad45885494(panels) {
    return Array.from(panels.values()).sort((a, b)=>a.order - b.order);
}
function $d520236daad9c5d5$var$safeResizePanel(panel, delta, prevSize, event) {
    const nextSizeUnsafe = prevSize + delta;
    if (panel.collapsible) {
        if (prevSize > 0) {
            if (nextSizeUnsafe <= 0) return 0;
        } else {
            const isKeyboardEvent = event?.type?.startsWith("key");
            if (!isKeyboardEvent) {
                // Keyboard events should expand a collapsed panel to the min size,
                // but mouse events should wait until the panel has reached its min size
                // to avoid a visual flickering when dragging between collapsed and min size.
                if (nextSizeUnsafe < panel.minSize) return 0;
            }
        }
    }
    const nextSize = Math.min(panel.maxSize, Math.max(panel.minSize, nextSizeUnsafe));
    return nextSize;
}


function $f5af57c8e042a4ad$export$ec391ce65b083ed4(event, handleId, direction, initialOffset = 0) {
    const isHorizontal = direction === "horizontal";
    let pointerOffset = 0;
    if ($f5af57c8e042a4ad$export$764db16956f554f8(event)) pointerOffset = isHorizontal ? event.clientX : event.clientY;
    else if ($f5af57c8e042a4ad$export$c4dfce035d43d1e0(event)) {
        const firstTouch = event.touches[0];
        pointerOffset = isHorizontal ? firstTouch.screenX : firstTouch.screenY;
    } else return 0;
    const handleElement = (0, $d520236daad9c5d5$export$2e27d3a347680388)(handleId);
    const rect = handleElement.getBoundingClientRect();
    const elementOffset = isHorizontal ? rect.left : rect.top;
    return pointerOffset - elementOffset - initialOffset;
}
function $f5af57c8e042a4ad$export$354b17c0684607ed(event, groupId, handleId, panelsArray, direction, sizes, initialOffset) {
    if ($f5af57c8e042a4ad$export$e7bf60a870f429b0(event)) {
        const isHorizontal = direction === "horizontal";
        const groupElement = (0, $d520236daad9c5d5$export$5e67632cf3550a9c)(groupId);
        const rect = groupElement.getBoundingClientRect();
        const groupSizeInPixels = isHorizontal ? rect.width : rect.height;
        const denominator = event.shiftKey ? 10 : 100;
        const delta = groupSizeInPixels / denominator;
        let movement = 0;
        switch(event.key){
            case "ArrowDown":
                movement = isHorizontal ? 0 : delta;
                break;
            case "ArrowLeft":
                movement = isHorizontal ? -delta : 0;
                break;
            case "ArrowRight":
                movement = isHorizontal ? delta : 0;
                break;
            case "ArrowUp":
                movement = isHorizontal ? 0 : -delta;
                break;
            case "End":
                movement = groupSizeInPixels;
                break;
            case "Home":
                movement = -groupSizeInPixels;
                break;
        }
        // If the Panel being resized is collapsible,
        // we need to special case resizing around the minSize boundary.
        // If contracting, Panels should shrink to their minSize and then snap to fully collapsed.
        // If expanding from collapsed, they should snap back to their minSize.
        const [idBefore, idAfter] = (0, $d520236daad9c5d5$export$68d3a33c21dfbe27)(groupId, handleId, panelsArray);
        const targetPanelId = movement < 0 ? idBefore : idAfter;
        const targetPanelIndex = panelsArray.findIndex((panel)=>panel.id === targetPanelId);
        const targetPanel = panelsArray[targetPanelIndex];
        if (targetPanel.collapsible) {
            const prevSize = sizes[targetPanelIndex];
            if (prevSize === 0 || prevSize.toPrecision((0, $3237bc4a138172cd$export$d6d3992f3becc879)) === targetPanel.minSize.toPrecision((0, $3237bc4a138172cd$export$d6d3992f3becc879))) movement = movement < 0 ? -targetPanel.minSize * groupSizeInPixels : targetPanel.minSize * groupSizeInPixels;
        }
        return movement;
    } else return $f5af57c8e042a4ad$export$ec391ce65b083ed4(event, handleId, direction, initialOffset);
}
function $f5af57c8e042a4ad$export$e7bf60a870f429b0(event) {
    return event.type === "keydown";
}
function $f5af57c8e042a4ad$export$764db16956f554f8(event) {
    return event.type.startsWith("mouse");
}
function $f5af57c8e042a4ad$export$c4dfce035d43d1e0(event) {
    return event.type.startsWith("touch");
}








function $63be9a96d8675f03$export$d9fcbe062527d159({ committedValuesRef: committedValuesRef , groupId: groupId , panels: panels , setSizes: setSizes , sizes: sizes , panelSizeBeforeCollapse: panelSizeBeforeCollapse  }) {
    (0, $b2QPe$react.useEffect)(()=>{
        const { direction: direction , panels: panels  } = committedValuesRef.current;
        const groupElement = (0, $d520236daad9c5d5$export$5e67632cf3550a9c)(groupId);
        const { height: height , width: width  } = groupElement.getBoundingClientRect();
        const handles = (0, $d520236daad9c5d5$export$ae14931f0a0256a3)(groupId);
        const cleanupFunctions = handles.map((handle)=>{
            const handleId = handle.getAttribute("data-panel-resize-handle-id");
            const panelsArray = (0, $d520236daad9c5d5$export$a861c0ad45885494)(panels);
            const [idBefore, idAfter] = (0, $d520236daad9c5d5$export$68d3a33c21dfbe27)(groupId, handleId, panelsArray);
            if (idBefore == null || idAfter == null) return ()=>{};
            let minSize = 0;
            let maxSize = 100;
            let totalMinSize = 0;
            let totalMaxSize = 0;
            // A panel's effective min/max sizes also need to account for other panel's sizes.
            panelsArray.forEach((panelData)=>{
                if (panelData.id === idBefore) {
                    maxSize = panelData.maxSize;
                    minSize = panelData.minSize;
                } else {
                    totalMinSize += panelData.minSize;
                    totalMaxSize += panelData.maxSize;
                }
            });
            const ariaValueMax = Math.min(maxSize, 100 - totalMinSize);
            const ariaValueMin = Math.max(minSize, (panelsArray.length - 1) * 100 - totalMaxSize);
            const flexGrow = (0, $d520236daad9c5d5$export$6f43503e166de6fb)(panels, idBefore, sizes);
            handle.setAttribute("aria-valuemax", "" + Math.round(ariaValueMax));
            handle.setAttribute("aria-valuemin", "" + Math.round(ariaValueMin));
            handle.setAttribute("aria-valuenow", "" + Math.round(parseInt(flexGrow)));
            const onKeyDown = (event)=>{
                switch(event.key){
                    case "Enter":
                        {
                            const index = panelsArray.findIndex((panel)=>panel.id === idBefore);
                            if (index >= 0) {
                                const panelData = panelsArray[index];
                                const size = sizes[index];
                                if (size != null) {
                                    let delta = 0;
                                    if (size.toPrecision((0, $3237bc4a138172cd$export$d6d3992f3becc879)) <= panelData.minSize.toPrecision((0, $3237bc4a138172cd$export$d6d3992f3becc879))) delta = direction === "horizontal" ? width : height;
                                    else delta = -(direction === "horizontal" ? width : height);
                                    const nextSizes = (0, $d520236daad9c5d5$export$f50bae335f53943c)(event, panels, idBefore, idAfter, delta, sizes, panelSizeBeforeCollapse.current);
                                    if (sizes !== nextSizes) setSizes(nextSizes);
                                }
                            }
                            break;
                        }
                }
            };
            handle.addEventListener("keydown", onKeyDown);
            const panelBefore = (0, $d520236daad9c5d5$export$7361ed18ff57179e)(idBefore);
            if (panelBefore != null) handle.setAttribute("aria-controls", panelBefore.id);
            return ()=>{
                handle.removeAttribute("aria-valuemax");
                handle.removeAttribute("aria-valuemin");
                handle.removeAttribute("aria-valuenow");
                handle.removeEventListener("keydown", onKeyDown);
                if (panelBefore != null) handle.removeAttribute("aria-controls");
            };
        });
        return ()=>{
            cleanupFunctions.forEach((cleanupFunction)=>cleanupFunction());
        };
    }, [
        groupId,
        panels,
        sizes
    ]);
}
function $63be9a96d8675f03$export$33b0bea6ac3ffb03({ disabled: disabled , handleId: handleId , resizeHandler: resizeHandler  }) {
    (0, $b2QPe$react.useEffect)(()=>{
        if (disabled || resizeHandler == null) return;
        const handleElement = (0, $d520236daad9c5d5$export$2e27d3a347680388)(handleId);
        if (handleElement == null) return;
        const onKeyDown = (event)=>{
            switch(event.key){
                case "ArrowDown":
                case "ArrowLeft":
                case "ArrowRight":
                case "ArrowUp":
                case "End":
                case "Home":
                    resizeHandler(event);
                    break;
                case "F6":
                    {
                        const handles = (0, $d520236daad9c5d5$export$8d0cd3c32ddc045e)();
                        const index = (0, $d520236daad9c5d5$export$96a40be80fb6c3c8)(handleId);
                        const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;
                        const nextHandle = handles[nextIndex];
                        nextHandle.focus();
                        break;
                    }
            }
        };
        handleElement.addEventListener("keydown", onKeyDown);
        return ()=>{
            handleElement.removeEventListener("keydown", onKeyDown);
        };
    }, [
        disabled,
        handleId,
        resizeHandler
    ]);
}


let $102aa6bc0f99b2b3$var$currentState = null;
let $102aa6bc0f99b2b3$var$element = null;
function $102aa6bc0f99b2b3$export$fa35f3322c52262f(state) {
    switch(state){
        case "horizontal":
            return "col-resize";
        case "horizontal-max":
            return "w-resize";
        case "horizontal-min":
            return "e-resize";
        case "vertical":
            return "row-resize";
        case "vertical-max":
            return "n-resize";
        case "vertical-min":
            return "s-resize";
    }
}
function $102aa6bc0f99b2b3$export$b61932ee18f96e08() {
    if ($102aa6bc0f99b2b3$var$element !== null) {
        document.head.removeChild($102aa6bc0f99b2b3$var$element);
        $102aa6bc0f99b2b3$var$currentState = null;
        $102aa6bc0f99b2b3$var$element = null;
    }
}
function $102aa6bc0f99b2b3$export$d395b5dfd066a659(state) {
    if ($102aa6bc0f99b2b3$var$currentState === state) return;
    $102aa6bc0f99b2b3$var$currentState = state;
    const style = $102aa6bc0f99b2b3$export$fa35f3322c52262f(state);
    if ($102aa6bc0f99b2b3$var$element === null) {
        $102aa6bc0f99b2b3$var$element = document.createElement("style");
        document.head.appendChild($102aa6bc0f99b2b3$var$element);
    }
    $102aa6bc0f99b2b3$var$element.innerHTML = `*{cursor: ${style}!important;}`;
}


function $0f7a23424493ebd6$export$2e2bcd8739ae039(callback, durationMs = 10) {
    let timeoutId = null;
    let callable = (...args)=>{
        clearTimeout(timeoutId);
        timeoutId = setTimeout(()=>{
            callback(...args);
        }, durationMs);
    };
    return callable;
}


// Limit the frequency of localStorage updates.
const $19bf0050f73d236b$var$savePanelGroupLayoutDebounced = (0, $0f7a23424493ebd6$export$2e2bcd8739ae039)((0, $e045b0dd313f33c7$export$af183b313c61be4f), 100);
function $19bf0050f73d236b$export$1d05749f6f573bb({ autoSaveId: autoSaveId , children: children = null , className: classNameFromProps = "" , direction: direction , id: idFromProps = null , onLayout: onLayout = null , style: styleFromProps = {} , tagName: Type = "div"  }) {
    const groupId = (0, $6d548a0d130941e3$export$2e2bcd8739ae039)(idFromProps);
    const [activeHandleId, setActiveHandleId] = (0, $b2QPe$react.useState)(null);
    const [panels, setPanels] = (0, $b2QPe$react.useState)(new Map());
    // Use a ref to guard against users passing inline props
    const callbacksRef = (0, $b2QPe$react.useRef)({
        onLayout: onLayout
    });
    (0, $b2QPe$react.useEffect)(()=>{
        callbacksRef.current.onLayout = onLayout;
    });
    // 0-1 values representing the relative size of each panel.
    const [sizes, setSizes] = (0, $b2QPe$react.useState)([]);
    // Resize is calculated by the distance between the current pointer event and the resize handle being "dragged"
    // This value accounts for the initial offset when the touch/click starts, so the handle doesn't appear to "jump"
    const dragOffsetRef = (0, $b2QPe$react.useRef)(0);
    // Used to support imperative collapse/expand API.
    const panelSizeBeforeCollapse = (0, $b2QPe$react.useRef)(new Map());
    // Store committed values to avoid unnecessarily re-running memoization/effects functions.
    const committedValuesRef = (0, $b2QPe$react.useRef)({
        direction: direction,
        panels: panels,
        sizes: sizes
    });
    (0, $967abed3d1bd1fe9$export$2e2bcd8739ae039)(()=>{
        committedValuesRef.current.direction = direction;
        committedValuesRef.current.panels = panels;
        committedValuesRef.current.sizes = sizes;
    });
    (0, $63be9a96d8675f03$export$d9fcbe062527d159)({
        committedValuesRef: committedValuesRef,
        groupId: groupId,
        panels: panels,
        setSizes: setSizes,
        sizes: sizes,
        panelSizeBeforeCollapse: panelSizeBeforeCollapse
    });
    // Notify external code when sizes have changed.
    (0, $b2QPe$react.useEffect)(()=>{
        const { onLayout: onLayout  } = callbacksRef.current;
        if (onLayout) {
            const { sizes: sizes  } = committedValuesRef.current;
            // Don't commit layout until all panels have registered and re-rendered with their actual sizes.
            if (sizes.length > 0) onLayout(sizes);
        }
    }, [
        sizes
    ]);
    // Notify Panel listeners about their initial sizes and collapsed state after mount.
    // Subsequent changes will be called by the resizeHandler.
    const didNotifyCallbacksAfterMountRef = (0, $b2QPe$react.useRef)(false);
    (0, $967abed3d1bd1fe9$export$2e2bcd8739ae039)(()=>{
        if (didNotifyCallbacksAfterMountRef.current) return;
        const { panels: panels , sizes: sizes  } = committedValuesRef.current;
        if (sizes.length > 0) {
            didNotifyCallbacksAfterMountRef.current = true;
            const panelsArray = (0, $d520236daad9c5d5$export$a861c0ad45885494)(panels);
            (0, $d520236daad9c5d5$export$b8e48269e4faa934)(panelsArray, [], sizes);
        }
    }, [
        sizes
    ]);
    // Once all panels have registered themselves,
    // Compute the initial sizes based on default weights.
    // This assumes that panels register during initial mount (no conditional rendering)!
    (0, $967abed3d1bd1fe9$export$2e2bcd8739ae039)(()=>{
        const sizes = committedValuesRef.current.sizes;
        if (sizes.length === panels.size) // Only compute (or restore) default sizes once per panel configuration.
        return;
        // If this panel has been configured to persist sizing information,
        // default size should be restored from local storage if possible.
        let defaultSizes = undefined;
        if (autoSaveId) {
            const panelsArray = (0, $d520236daad9c5d5$export$a861c0ad45885494)(panels);
            defaultSizes = (0, $e045b0dd313f33c7$export$9c80c6617f0386da)(autoSaveId, panelsArray);
        }
        if (defaultSizes != null) setSizes(defaultSizes);
        else {
            const panelsArray1 = (0, $d520236daad9c5d5$export$a861c0ad45885494)(panels);
            let panelsWithNullDefaultSize = 0;
            let totalDefaultSize = 0;
            let totalMinSize = 0;
            // TODO
            // Implicit default size calculations below do not account for inferred min/max size values.
            // e.g. if Panel A has a maxSize of 40 then Panels A and B can't both have an implicit default size of 50.
            // For now, these logic edge cases are left to the user to handle via props.
            panelsArray1.forEach((panel)=>{
                totalMinSize += panel.minSize;
                if (panel.defaultSize === null) panelsWithNullDefaultSize++;
                else totalDefaultSize += panel.defaultSize;
            });
            if (totalDefaultSize > 100) throw new Error(`The sum of the defaultSize of all panels in a group cannot exceed 100.`);
            else if (totalMinSize > 100) throw new Error(`The sum of the minSize of all panels in a group cannot exceed 100.`);
            setSizes(panelsArray1.map((panel)=>{
                if (panel.defaultSize === null) return (100 - totalDefaultSize) / panelsWithNullDefaultSize;
                return panel.defaultSize;
            }));
        }
    }, [
        autoSaveId,
        panels
    ]);
    (0, $b2QPe$react.useEffect)(()=>{
        // If this panel has been configured to persist sizing information, save sizes to local storage.
        if (autoSaveId) {
            if (sizes.length === 0 || sizes.length !== panels.size) return;
            const panelsArray = (0, $d520236daad9c5d5$export$a861c0ad45885494)(panels);
            $19bf0050f73d236b$var$savePanelGroupLayoutDebounced(autoSaveId, panelsArray, sizes);
        }
    }, [
        autoSaveId,
        panels,
        sizes
    ]);
    const getPanelStyle = (0, $b2QPe$react.useCallback)((id)=>{
        const { panels: panels  } = committedValuesRef.current;
        // Before mounting, Panels will not yet have registered themselves.
        // This includes server rendering.
        // At this point the best we can do is render everything with the same size.
        if (panels.size === 0) return {
            flexBasis: "auto",
            flexGrow: 1,
            flexShrink: 1,
            // Without this, Panel sizes may be unintentionally overridden by their content.
            overflow: "hidden"
        };
        const flexGrow = (0, $d520236daad9c5d5$export$6f43503e166de6fb)(panels, id, sizes);
        return {
            flexBasis: 0,
            flexGrow: flexGrow,
            flexShrink: 1,
            // Without this, Panel sizes may be unintentionally overridden by their content.
            overflow: "hidden",
            // Disable pointer events inside of a panel during resize.
            // This avoid edge cases like nested iframes.
            pointerEvents: activeHandleId !== null ? "none" : undefined
        };
    }, [
        activeHandleId,
        direction,
        sizes
    ]);
    const registerPanel = (0, $b2QPe$react.useCallback)((id, panel)=>{
        setPanels((prevPanels)=>{
            if (prevPanels.has(id)) return prevPanels;
            const nextPanels = new Map(prevPanels);
            nextPanels.set(id, panel);
            return nextPanels;
        });
    }, []);
    const registerResizeHandle = (0, $b2QPe$react.useCallback)((handleId)=>{
        const resizeHandler = (event)=>{
            event.preventDefault();
            const { direction: direction , panels: panels , sizes: prevSizes  } = committedValuesRef.current;
            const panelsArray = (0, $d520236daad9c5d5$export$a861c0ad45885494)(panels);
            const [idBefore, idAfter] = (0, $d520236daad9c5d5$export$68d3a33c21dfbe27)(groupId, handleId, panelsArray);
            if (idBefore == null || idAfter == null) return;
            const movement = (0, $f5af57c8e042a4ad$export$354b17c0684607ed)(event, groupId, handleId, panelsArray, direction, prevSizes, dragOffsetRef.current);
            if (movement === 0) return;
            const groupElement = (0, $d520236daad9c5d5$export$5e67632cf3550a9c)(groupId);
            const rect = groupElement.getBoundingClientRect();
            const isHorizontal = direction === "horizontal";
            const size = isHorizontal ? rect.width : rect.height;
            const delta = movement / size * 100;
            const nextSizes = (0, $d520236daad9c5d5$export$f50bae335f53943c)(event, panels, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current);
            if (prevSizes === nextSizes) {
                // If the pointer has moved too far to resize the panel any further,
                // update the cursor style for a visual clue.
                // This mimics VS Code behavior.
                if (isHorizontal) (0, $102aa6bc0f99b2b3$export$d395b5dfd066a659)(movement < 0 ? "horizontal-min" : "horizontal-max");
                else (0, $102aa6bc0f99b2b3$export$d395b5dfd066a659)(movement < 0 ? "vertical-min" : "vertical-max");
            } else {
                // Reset the cursor style to the the normal resize cursor.
                (0, $102aa6bc0f99b2b3$export$d395b5dfd066a659)(isHorizontal ? "horizontal" : "vertical");
                // If resize change handlers have been declared, this is the time to call them.
                (0, $d520236daad9c5d5$export$b8e48269e4faa934)(panelsArray, prevSizes, nextSizes);
                setSizes(nextSizes);
            }
        };
        return resizeHandler;
    }, [
        groupId
    ]);
    const unregisterPanel = (0, $b2QPe$react.useCallback)((id)=>{
        setPanels((prevPanels)=>{
            if (!prevPanels.has(id)) return prevPanels;
            const nextPanels = new Map(prevPanels);
            nextPanels.delete(id);
            return nextPanels;
        });
    }, []);
    const collapsePanel = (0, $b2QPe$react.useCallback)((id)=>{
        const { panels: panels , sizes: prevSizes  } = committedValuesRef.current;
        const panel = panels.get(id);
        if (panel == null || !panel.collapsible) return;
        const panelsArray = (0, $d520236daad9c5d5$export$a861c0ad45885494)(panels);
        const index = panelsArray.indexOf(panel);
        if (index < 0) return;
        const currentSize = prevSizes[index];
        if (currentSize === 0) // Panel is already collapsed.
        return;
        panelSizeBeforeCollapse.current.set(id, currentSize);
        const [idBefore, idAfter] = (0, $d520236daad9c5d5$export$5a5b0c1d38c23c3b)(id, panelsArray);
        if (idBefore == null || idAfter == null) return;
        const isLastPanel = index === panelsArray.length - 1;
        const delta = isLastPanel ? currentSize : 0 - currentSize;
        const nextSizes = (0, $d520236daad9c5d5$export$f50bae335f53943c)(null, panels, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current);
        if (prevSizes !== nextSizes) {
            // If resize change handlers have been declared, this is the time to call them.
            (0, $d520236daad9c5d5$export$b8e48269e4faa934)(panelsArray, prevSizes, nextSizes);
            setSizes(nextSizes);
        }
    }, []);
    const expandPanel = (0, $b2QPe$react.useCallback)((id)=>{
        const { panels: panels , sizes: prevSizes  } = committedValuesRef.current;
        const panel = panels.get(id);
        if (panel == null) return;
        const sizeBeforeCollapse = panelSizeBeforeCollapse.current.get(id) || panel.minSize;
        if (!sizeBeforeCollapse) return;
        const panelsArray = (0, $d520236daad9c5d5$export$a861c0ad45885494)(panels);
        const index = panelsArray.indexOf(panel);
        if (index < 0) return;
        const currentSize = prevSizes[index];
        if (currentSize !== 0) // Panel is already expanded.
        return;
        const [idBefore, idAfter] = (0, $d520236daad9c5d5$export$5a5b0c1d38c23c3b)(id, panelsArray);
        if (idBefore == null || idAfter == null) return;
        const isLastPanel = index === panelsArray.length - 1;
        const delta = isLastPanel ? 0 - sizeBeforeCollapse : sizeBeforeCollapse;
        const nextSizes = (0, $d520236daad9c5d5$export$f50bae335f53943c)(null, panels, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current);
        if (prevSizes !== nextSizes) {
            // If resize change handlers have been declared, this is the time to call them.
            (0, $d520236daad9c5d5$export$b8e48269e4faa934)(panelsArray, prevSizes, nextSizes);
            setSizes(nextSizes);
        }
    }, []);
    const resizePanel = (0, $b2QPe$react.useCallback)((id, nextSize)=>{
        const { panels: panels , sizes: prevSizes  } = committedValuesRef.current;
        const panel = panels.get(id);
        if (panel == null) return;
        const panelsArray = (0, $d520236daad9c5d5$export$a861c0ad45885494)(panels);
        const index = panelsArray.indexOf(panel);
        if (index < 0) return;
        const currentSize = prevSizes[index];
        if (currentSize === nextSize) return;
        const [idBefore, idAfter] = (0, $d520236daad9c5d5$export$5a5b0c1d38c23c3b)(id, panelsArray);
        if (idBefore == null || idAfter == null) return;
        const isLastPanel = index === panelsArray.length - 1;
        const delta = isLastPanel ? currentSize - nextSize : nextSize - currentSize;
        const nextSizes = (0, $d520236daad9c5d5$export$f50bae335f53943c)(null, panels, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current);
        if (prevSizes !== nextSizes) {
            // If resize change handlers have been declared, this is the time to call them.
            (0, $d520236daad9c5d5$export$b8e48269e4faa934)(panelsArray, prevSizes, nextSizes);
            setSizes(nextSizes);
        }
    }, []);
    const context = (0, $b2QPe$react.useMemo)(()=>({
            activeHandleId: activeHandleId,
            collapsePanel: collapsePanel,
            direction: direction,
            expandPanel: expandPanel,
            getPanelStyle: getPanelStyle,
            groupId: groupId,
            registerPanel: registerPanel,
            registerResizeHandle: registerResizeHandle,
            resizePanel: resizePanel,
            startDragging: (id, event)=>{
                setActiveHandleId(id);
                dragOffsetRef.current = (0, $f5af57c8e042a4ad$export$ec391ce65b083ed4)(event, id, direction);
            },
            stopDragging: ()=>{
                (0, $102aa6bc0f99b2b3$export$b61932ee18f96e08)();
                setActiveHandleId(null);
            },
            unregisterPanel: unregisterPanel
        }), [
        activeHandleId,
        collapsePanel,
        direction,
        expandPanel,
        getPanelStyle,
        groupId,
        registerPanel,
        registerResizeHandle,
        resizePanel,
        unregisterPanel
    ]);
    const style = {
        display: "flex",
        flexDirection: direction === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
    };
    return (0, $b2QPe$react.createElement)((0, $3251d17c1c3bce6c$export$7d8c6d083caec74a).Provider, {
        children: (0, $b2QPe$react.createElement)(Type, {
            children: children,
            className: classNameFromProps,
            "data-panel-group-direction": direction,
            "data-panel-group-id": groupId,
            style: {
                ...style,
                ...styleFromProps
            }
        }),
        value: context
    });
}
// Workaround for Parcel scope hoisting (which renames objects/functions).
// Casting to :any is required to avoid corrupting the generated TypeScript types.
// See github.com/parcel-bundler/parcel/issues/8724
$19bf0050f73d236b$export$1d05749f6f573bb.displayName = "PanelGroup";







function $01377e07790cf46f$export$8829ecf6b6b15484({ children: children = null , className: classNameFromProps = "" , disabled: disabled = false , id: idFromProps = null , style: styleFromProps = {} , tagName: Type = "div"  }) {
    const divElementRef = (0, $b2QPe$react.useRef)(null);
    const panelGroupContext = (0, $b2QPe$react.useContext)((0, $3251d17c1c3bce6c$export$7d8c6d083caec74a));
    if (panelGroupContext === null) throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);
    const { activeHandleId: activeHandleId , direction: direction , groupId: groupId , registerResizeHandle: registerResizeHandle , startDragging: startDragging , stopDragging: stopDragging  } = panelGroupContext;
    const resizeHandleId = (0, $6d548a0d130941e3$export$2e2bcd8739ae039)(idFromProps);
    const isDragging = activeHandleId === resizeHandleId;
    const [isFocused, setIsFocused] = (0, $b2QPe$react.useState)(false);
    const [resizeHandler, setResizeHandler] = (0, $b2QPe$react.useState)(null);
    const stopDraggingAndBlur = (0, $b2QPe$react.useCallback)(()=>{
        // Clicking on the drag handle shouldn't leave it focused;
        // That would cause the PanelGroup to think it was still active.
        const div = divElementRef.current;
        div.blur();
        stopDragging();
    }, [
        stopDragging
    ]);
    (0, $b2QPe$react.useEffect)(()=>{
        if (disabled) setResizeHandler(null);
        else {
            const resizeHandler = registerResizeHandle(resizeHandleId);
            setResizeHandler(()=>resizeHandler);
        }
    }, [
        disabled,
        resizeHandleId,
        registerResizeHandle
    ]);
    (0, $b2QPe$react.useEffect)(()=>{
        if (disabled || resizeHandler == null || !isDragging) return;
        const onMove = (event)=>{
            resizeHandler(event);
        };
        document.body.addEventListener("contextmenu", stopDraggingAndBlur);
        document.body.addEventListener("mousemove", onMove);
        document.body.addEventListener("touchmove", onMove);
        window.addEventListener("mouseup", stopDraggingAndBlur);
        window.addEventListener("touchend", stopDraggingAndBlur);
        return ()=>{
            document.body.removeEventListener("contextmenu", stopDraggingAndBlur);
            document.body.removeEventListener("mousemove", onMove);
            document.body.removeEventListener("touchmove", onMove);
            window.removeEventListener("mouseup", stopDraggingAndBlur);
            window.removeEventListener("touchend", stopDraggingAndBlur);
        };
    }, [
        direction,
        disabled,
        isDragging,
        resizeHandler,
        stopDraggingAndBlur
    ]);
    (0, $63be9a96d8675f03$export$33b0bea6ac3ffb03)({
        disabled: disabled,
        handleId: resizeHandleId,
        resizeHandler: resizeHandler
    });
    const style = {
        cursor: (0, $102aa6bc0f99b2b3$export$fa35f3322c52262f)(direction),
        touchAction: "none",
        userSelect: "none"
    };
    return (0, $b2QPe$react.createElement)(Type, {
        children: children,
        className: classNameFromProps,
        "data-resize-handle-active": isDragging ? "pointer" : isFocused ? "keyboard" : undefined,
        "data-panel-group-direction": direction,
        "data-panel-group-id": groupId,
        "data-panel-resize-handle-enabled": !disabled,
        "data-panel-resize-handle-id": resizeHandleId,
        onBlur: ()=>setIsFocused(false),
        onFocus: ()=>setIsFocused(true),
        onMouseDown: (event)=>startDragging(resizeHandleId, event.nativeEvent),
        onMouseUp: stopDraggingAndBlur,
        onTouchCancel: stopDraggingAndBlur,
        onTouchEnd: stopDraggingAndBlur,
        onTouchStart: (event)=>startDragging(resizeHandleId, event.nativeEvent),
        ref: divElementRef,
        role: "separator",
        style: {
            ...style,
            ...styleFromProps
        },
        tabIndex: 0
    });
}
// Workaround for Parcel scope hoisting (which renames objects/functions).
// Casting to :any is required to avoid corrupting the generated TypeScript types.
// See github.com/parcel-bundler/parcel/issues/8724
$01377e07790cf46f$export$8829ecf6b6b15484.displayName = "PanelResizeHandle";




//# sourceMappingURL=react-resizable-panels.js.map

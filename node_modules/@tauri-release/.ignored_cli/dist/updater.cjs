'use strict';

const fs = require('fs');
const path = require('path');
const fetch = require('node-fetch');
const github = require('@actions/github');
const utils = require('./shared/cli.de4d4f3c.cjs');
const updatelog = require('./updatelog.cjs');
require('module');

async function updater() {
  const argv = utils.$argv();
  let owner, repo;
  try {
    owner = github.context?.repo?.owner;
    repo = github.context?.repo?.repo;
  } catch (_) {
    if (argv.owner) {
      owner = argv.owner;
    }
    if (argv.repo) {
      repo = argv.repo;
    }
  }
  if (!owner || !owner || !argv.token) {
    console.log(utils.$.red("[\u{1F4A2} updater]"), "`owner`, `repo`, `token` are required.");
    process.exit(0);
  }
  let filename = utils.UPDATER_JSON_PATH;
  if (argv.output) {
    filename = path.join(utils.ROOT_PATH, argv.output);
    if (!/.json$/.test(filename)) {
      console.log(utils.$.red("[\u{1F4A2} updater]"), utils.$.yellow(filename), `The output file format must be json`);
      process.exit(0);
    }
  }
  if (!fs.existsSync(path.dirname(filename))) {
    fs.mkdirSync(path.dirname(filename), { recursive: true });
  }
  const options = { owner, repo };
  const github$1 = github.getOctokit(argv.token);
  const { data: tags } = await github$1.rest.repos.listTags({
    ...options,
    per_page: 10,
    page: 1
  });
  const tag = tags.find((t) => t.name.startsWith("v"));
  if (!tag)
    return;
  const { data: latestRelease } = await github$1.rest.repos.getReleaseByTag({
    ...options,
    tag: tag.name
  });
  const { content } = updatelog(tag.name);
  const updateData = {
    version: tag.name,
    notes: content,
    pub_date: new Date().toISOString(),
    platforms: {
      win64: { signature: "", url: "" },
      linux: { signature: "", url: "" },
      darwin: { signature: "", url: "" },
      "darwin-aarch64": { signature: "", url: "" },
      "darwin-x86_64": { signature: "", url: "" },
      "linux-x86_64": { signature: "", url: "" },
      "windows-x86_64": { signature: "", url: "" }
    }
  };
  const setAsset = async (asset, reg, platforms) => {
    let sig = "";
    if (/.sig$/.test(asset.name)) {
      sig = await getSignature(asset.browser_download_url);
    }
    platforms.forEach((platform) => {
      if (/aarch64/.test(asset.name)) {
        if (/.app.tar.gz/.test(asset.name)) {
          if (sig) {
            updateData.platforms["darwin-aarch64"].signature = sig;
            return;
          }
          updateData.platforms["darwin-aarch64"].url = asset.browser_download_url;
          return;
        }
      } else if (reg.test(asset.name)) {
        if (sig) {
          updateData.platforms[platform].signature = sig;
          return;
        }
        updateData.platforms[platform].url = asset.browser_download_url;
      }
    });
  };
  const promises = latestRelease.assets.map(async (asset) => {
    await setAsset(asset, /.msi.zip/, ["win64", "windows-x86_64"]);
    await setAsset(asset, /.app.tar.gz/, [
      "darwin",
      "darwin-x86_64",
      "darwin-aarch64"
    ]);
    await setAsset(asset, /.AppImage.tar.gz/, ["linux", "linux-x86_64"]);
  });
  await Promise.allSettled(promises);
  fs.writeFileSync(filename, JSON.stringify(updateData, null, 2));
  console.log(utils.$.green("[\u2728 updater]"), utils.$.green(utils.relativePath(filename)), "\n");
  console.log(utils.$.yellow("*".repeat(20)));
  console.log(utils.$.yellow("*"), utils.$.blue("Edit `.github/workflows/release.yml > peaceiris/actions-gh-pages > publish_dir"));
  console.log(utils.$.yellow("*"), utils.$.gray("value:"), utils.$.green(utils.relativePath(path.dirname(filename))));
  console.log(utils.$.yellow("*"), utils.$.blue("Edit `tauri.conf.json > tauri > updater > endpoints`"));
  console.log(utils.$.yellow("*"), utils.$.gray("value:"), utils.$.green(`https://${owner}.github.io/${repo}/${path.basename(filename)}`));
  console.log(utils.$.yellow("*".repeat(20)));
}
async function getSignature(url) {
  try {
    const response = await fetch(url, {
      method: "GET",
      headers: { "Content-Type": "application/octet-stream" }
    });
    return response.text();
  } catch (_) {
    return "";
  }
}

module.exports = updater;
